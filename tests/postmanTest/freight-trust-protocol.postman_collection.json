{
	"info": {
		"_postman_id": "",
		"name": "Freight Trust and Clearing NFT EDI Protocol",
		"description": "EDI X12/EDIFACT dApp which allows recording, transfering and signing of EDI Generated Documents, such as bills of lading or warehouse receipts.",
		"schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json"
	},
	"item": [
		{
			"name": "nft",
			"item": [
				{
					"name": "Returns the token contract's name",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "59be27be-81b0-411c-b2b4-72e970aee35f",
								"exec": [
									"pm.test(\"Returns the right name\", function () {",
									"    response = pm.response.json();",
									"    pm.expect(response[\"name\"]).to.eql(\"Bill of Lading\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": "localhost:3000/nft/name"
					},
					"response": []
				},
				{
					"name": "Returns the token contract's symbol",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "db90084a-d718-41c3-a2c6-2e5740033441",
								"exec": [
									"pm.test(\"Returns the right symbol\", function () {",
									"    response = pm.response.json();",
									"    pm.expect(response[\"symbol\"]).to.eql(\"BOL\");",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": "localhost:3000/nft/symbol"
					},
					"response": []
				},
				{
					"name": "An API endpoint to get the total supply of tokens in the ERC721 contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "e0ccfec8-3cc6-4350-b897-dd5e44370b8f",
								"exec": [
									"pm.test(\"Returns the right type\", function () {",
									"    response = pm.response.json();",
									"    pm.expect(uintVerify(response[\"totalSupply\"])).to.eql(true);",
									"});",
									"",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665640564039457584007913129639935))",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": "localhost:3000/nft/totalSupply",
						"description": "Returns the total supply of Non fungible tokens"
					},
					"response": []
				},
				{
					"name": "Returns the Token URI",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "4e0a4b9e-1ef0-4bc8-a313-544b38d035a8",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"tokenId\"), 32)){",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof response[\"tokenURI\"]).to.eql(\"string\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/tokenURI/?tokenId={{tokenId}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "tokenURI", ""],
							"query": [
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns an interface's support status",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "faeef335-9767-430e-be06-fb1bcba0ee8b",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"interfaceId\"), 4)){",
									"        pm.response.to.have.status(200);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof response[\"supported\"]).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/supportsInterface/?interfaceId={{interfaceId}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "supportsInterface", ""],
							"query": [
								{
									"key": "interfaceId",
									"value": "{{interfaceId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns the token identifier of the `index`-th nft tracked by the contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "9b82ef0d-8d8f-485f-a906-92df552a12e4",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"index\"), 32)) {",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(uintVerify(response[\"token\"])).to.eql(true);",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/tokenByIndex/?index={{index}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "tokenByIndex", ""],
							"query": [
								{
									"key": "index",
									"value": "{{index}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Returns the token identifier of the `index`-th nft assigned to the `owner`",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "fb0e70b6-dd8d-4371-a8bf-9d1d54243a34",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(uintVerify(pm.variables.get(\"index\"))){",
									"        if(bytesVerify(pm.variables.get(\"owner\"), 20)){",
									"          pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"        }",
									"        else{",
									"          pm.expect(pm.response.code).to.be.oneOf([400, 425]);  ",
									"        }",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(uintVerify(response[\"token\"])).to.eql(true);",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/tokenOfOwnerByIndex/?owner={{owner}}&index={{index}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "tokenOfOwnerByIndex", ""],
							"query": [
								{
									"key": "owner",
									"value": "{{owner}}"
								},
								{
									"key": "index",
									"value": "{{index}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Count all NFTs assigned to an owner",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "1a8cfadf-74f4-4be1-b01e-6f0d20849674",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"owner\"), 20)) {",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    } else {",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(uintVerify(response[\"balance\"])).to.eql(true);",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/balanceOf/?owner={{owner}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "balanceOf", ""],
							"query": [
								{
									"key": "owner",
									"value": "{{owner}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Find the owner of an NFT",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "c38d575f-3f25-409f-b733-5898d2eb115e",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(uintVerify(pm.variables.get(\"tokenId\"))){",
									"        pm.expect(pm.response.code).to.be.oneOf([200, 425]);",
									"    } else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof bytesVerify(response[\"owner\"], 20)).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/ownerOf/?tokenId={{tokenId}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "ownerOf", ""],
							"query": [
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Transfers the ownership of an NFT from one address to another address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "12edba2f-86b6-4e86-b4ac-344cd37a3a86",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data\",",
									"\t return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code\",",
									"    proposed = proposed.toLowerCase()",
									"\tflag = (proposed.slice(0,2) == \"0x\")",
									"\tfor(i = 2;  i < proposed.length; i ++) {",
									"\t\ttest = proposed.charAt(i)",
									"\t\tflag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"\t}",
									"    return flag",
									"}",
									"function authVerify(authArray) {",
									"\tif((authArray.length != 4) ||",
									"\t\t(!bytesVerify(authArray[0], 32)) ||",
									"\t\t(!bytesVerify(authArray[1], 1)) ||",
									"\t\t(!bytesVerify(authArray[2], 32)) ||",
									"\t\t(!bytesVerify(authArray[3], 32)))",
									"\t{",
									"\t\treturn false;",
									"\t}",
									"\telse {",
									"\t    return true",
									"\t}",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"\tlet auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"\t\t\t\t\t\t\t\t\t ",
									"\tif(bytesVerify(pm.variables.get(\"from\"),20) && (bytesVerify(pm.variables.get(\"to\"),20)) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(auth)){",
									"\t\tpm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"\t}",
									"\telse {",
									"\t\tpm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"\t}",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/safeTransferFrom/?from={{from}}&to={{to}}&tokenId={{tokenId}}&extraData={{extraData}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "safeTransferFrom", ""],
							"query": [
								{
									"key": "from",
									"value": "{{from}}"
								},
								{
									"key": "to",
									"value": "{{to}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								},
								{
									"key": "extraData",
									"value": "{{extraData}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Transfer ownership of an NFT without safety checks",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "a2df5081-2bc9-4e17-8e0a-be857ed856e5",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"from\"),20) && (bytesVerify(pm.variables.get(\"to\"),20)) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/transferFrom/?from={{from}}&to={{to}}&tokenId={{tokenId}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "transferFrom", ""],
							"query": [
								{
									"key": "from",
									"value": "{{from}}"
								},
								{
									"key": "to",
									"value": "{{to}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						},
						"description": "Allows Freight Trust Corp. to tranfer tokens unsafely -- THE CALLER IS RESPONSIBLE TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE THEY MAY BE PERMANENTLY LOST"
					},
					"response": []
				},
				{
					"name": "Change or reaffirm the approved address for an NFT",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "e97f3f50-9fb6-400a-b503-e470ec47366a",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"approved\"),20) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/approve/?approved={{approved}}&tokenId={{tokenId}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "approve", ""],
							"query": [
								{
									"key": "approved",
									"value": "{{approved}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Allows Freight Trust Corp. to issue univeral approval",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "455699bb-aefe-4fb3-811d-b17a2fd5eff5",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if((typeof pm.variables.get(\"status\") == \"boolean\") && bytesVerify(pm.variables.get(\"operator\"),20)  && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/setApprovalForAll/?operator={{operator}}&status={{status}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "setApprovalForAll", ""],
							"query": [
								{
									"key": "operator",
									"value": "{{operator}}"
								},
								{
									"key": "status",
									"value": "{{status}}"
								}
							]
						},
						"description": "Enable or disable approval for a third party (`operator`) to manage all of Freight Trust Corp.'s assets"
					},
					"response": []
				},
				{
					"name": "Get the approved address for a single NFT",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "6556f411-3186-4cdd-8617-f5fe2d515a52",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(uintVerify(pm.variables.get(\"tokenId\"))){",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof bytesVerify(response[\"approved\"], 20)).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/getApproved/?tokenId={{tokenId}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "getApproved", ""],
							"query": [
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								}
							]
						},
						"description": "The approved address for this NFT, or the zero address if there is none"
					},
					"response": []
				},
				{
					"name": "Query if an address is an authorized operator for another address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "d3051178-46c8-4630-9fee-6e671238f720",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function uintVerify(proposed){",
									"  proposed = parseInt(proposed, 10);",
									"  return ((proposed >= 0) && (proposed < 115792089237316195423570985008687907853269984665642564239457584207913129639935))",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"operator\"),20)){",
									"        if(bytesVerify(pm.variables.get(\"owner\"),20)){",
									"          pm.response.to.have.status(200);",
									"        }",
									"        else{",
									"          pm.expect(pm.response.code).to.be.oneOf([400, 425])  ",
									"        }",
									"    }else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425])",
									"    }",
									"});",
									"",
									"pm.test(\"Returns the Right Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(typeof response[\"isApprovedForAll\"]).to.eql(\"boolean\");",
									"    } else if (responseCode.code == 400) {",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }  ",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/nft/isApprovedForAll/?owner={{owner}}&operator={{operator}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "isApprovedForAll", ""],
							"query": [
								{
									"key": "owner",
									"value": "{{owner}}"
								},
								{
									"key": "operator",
									"value": "{{operator}}"
								}
							]
						},
						"description": "True if `operator` is an approved operator for `owner`, false otherwise"
					},
					"response": []
				},
				{
					"name": "Signed Transfer",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "5c396c33-6b0a-4bcc-984f-8968ddff5c95",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let authBA = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    let authS = [pm.variables.get(\"hash1\"), pm.variables.get(\"v1\"), pm.variables.get(\"r1\") , pm.variables.get(\"s1\")]",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"from\"),20) && (bytesVerify(pm.variables.get(\"to\"),20)) && bytesVerify(pm.variables.get(\"tokenId\"), 32) && authVerify(authBA) && authVerify(authS)){",
									"       ",
									"        extraData = pm.variables.get(\"data\")",
									"        if((extraData.length%2 === 0) && bytesVerify(extraData, extraData.length/2 - 1)){",
									"          pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"        }",
									"        else{",
									"          pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"        }",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : {\n  \t\"freightTrustAuth\" : {\n  \t\t\"sig\": \"{{sig}}\"\n  \t\t\n  \t}, \"senderAuth\" : {\n  \t\t\"sig\": \"{{sig1}}\"\n  \t}\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/signedTransfer/?from={{from}}&to={{to}}&tokenId={{tokenId}}&data={{data}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "signedTransfer", ""],
							"query": [
								{
									"key": "from",
									"value": "{{from}}"
								},
								{
									"key": "to",
									"value": "{{to}}"
								},
								{
									"key": "tokenId",
									"value": "{{tokenId}}"
								},
								{
									"key": "data",
									"value": "{{data}}"
								}
							]
						},
						"description": "Allows Freight Trust Corp. to sign and transfer a ERC721 token on the behalf of its holder"
					},
					"response": []
				},
				{
					"name": "Creates a new record",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "8d0cbc72-fc5c-4319-b033-0ef7e3ccd6b5",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let authBA = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    let authOW = [pm.variables.get(\"hash1\"), pm.variables.get(\"v1\"), pm.variables.get(\"r1\") , pm.variables.get(\"s1\")];",
									"    let authP = [pm.variables.get(\"hash2\"), pm.variables.get(\"v2\"), pm.variables.get(\"r2\") , pm.variables.get(\"s2\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"recordID\"),32) && (bytesVerify(pm.variables.get(\"owner\"),20)) && bytesVerify(pm.variables.get(\"participant\"), 20) && authVerify(authBA) && authVerify(authOW) && authVerify(authP)){",
									"       ",
									"         pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : {\n  \t\"freightTrustAuth\" : {\n  \t\t\"sig\": \"{{sig}}\"\n  \t}, \n  \t\"ownerAuth\" : {\n  \t\t\"sig\": \"{{sig1}}\"\n  \t}, \"partAuth\" : {\n  \t\t\"sig\": \"{{sig2}}\"\n  \t}\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/createRecord/?recordID={{recordID}}&owner={{owner}}&participant={{participant}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "createRecord", ""],
							"query": [
								{
									"key": "recordID",
									"value": "{{recordID}}"
								},
								{
									"key": "owner",
									"value": "{{owner}}"
								},
								{
									"key": "participant",
									"value": "{{participant}}"
								}
							]
						},
						"description": "Allows Freight Trust Corp. to create a record with the signature of the owner and of the participant."
					},
					"response": []
				},
				{
					"name": "Versions a record for Freight Trust Corp.",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "88e6d198-5da6-4ace-a453-c74314359763",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let auth = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"currentHash\"),32) && bytesVerify(pm.variables.get(\"newHash\"),32) && authVerify(auth)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/versionRecord/?currentHash={{currentHash}}&newHash={{newHash}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "versionRecord", ""],
							"query": [
								{
									"key": "currentHash",
									"value": "{{currentHash}}"
								},
								{
									"key": "newHash",
									"value": "{{newHash}}"
								}
							]
						},
						"description": "Allows Freight Trust Corp. to version one of the records they own."
					},
					"response": []
				},
				{
					"name": "Versions a record for the owner",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "878f2a11-b00d-4b42-8376-6392da07d0a9",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    let authBA = [pm.variables.get(\"hash\"), pm.variables.get(\"v\"), pm.variables.get(\"r\") , pm.variables.get(\"s\")];",
									"    ",
									"    if(bytesVerify(pm.variables.get(\"currentHash\"),32) && bytesVerify(pm.variables.get(\"newHash\"),32) && bytesVerify(pm.variables.get(\"owner\"),20) && authVerify(authBA)){",
									"       ",
									"        pm.expect(pm.response.code).to.be.oneOf([200,425]);",
									"    }",
									"    else{",
									"        pm.expect(pm.response.code).to.be.oneOf([400,425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : {\n  \t\"freightTrustAuth\" : {\n  \t\t\"sig\": \"{{sig}}\"\n  \t}, \"ownerAuth\" : {\n  \t\t\"sig\": \"{{sig1}}\"\n  \t\t\n  \t}\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/nft/versionRecord/signed/?currentHash={{currentHash}}&newHash={{newHash}}&owner={{owner}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["nft", "versionRecord", "signed", ""],
							"query": [
								{
									"key": "currentHash",
									"value": "{{currentHash}}"
								},
								{
									"key": "newHash",
									"value": "{{newHash}}"
								},
								{
									"key": "owner",
									"value": "{{owner}}"
								}
							]
						},
						"description": "Allows Freight Trust Corp. to version a record for the owner using the owner's signature."
					},
					"response": []
				}
			],
			"description": "Folder for nft"
		},
		{
			"name": "proxy",
			"item": [
				{
					"name": "Gets address of Function",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "564dd7c6-a375-4e42-b351-a829a092d730",
								"type": "text/javascript",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(bytesVerify(pm.variables.get(\"id\"), 4)){",
									"        pm.response.to.have.status(200);",
									"    }else{",
									"        pm.response.to.have.status(400);",
									"    }",
									"});",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"target\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": {
							"raw": "localhost:3000/proxy/getTarget/?id={{id}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["proxy", "getTarget", ""],
							"query": [
								{
									"key": "id",
									"value": "{{id}}"
								}
							]
						},
						"description": "Gets address that is delegate called to run a function's logic."
					},
					"response": []
				},
				{
					"name": "Gets address of the Master Contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "922ef475-80bb-4800-bc15-eb7f102236c2",
								"type": "text/javascript",
								"exec": [
									"tests[\"Status code is 200\"] = responseCode.code === 200;",
									"",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"master\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});",
									"",
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": "localhost:3000/proxy/getMaster",
						"description": "Gets the address of the master contract."
					},
					"response": []
				},
				{
					"name": "Gets address of the controller Contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "174299a3-a5d8-4121-913a-a78f521b46a4",
								"exec": [
									"tests[\"Status code is 200\"] = responseCode.code === 200;",
									"",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"controller\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});",
									"",
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": "localhost:3000/proxy/getController",
						"description": "Gets the address of the controler contract."
					},
					"response": []
				},
				{
					"name": "Gets address of the Universal Proxy Contract",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "60a2d5d3-3bab-40ca-96b4-ae7dc2bbcbd5",
								"type": "text/javascript",
								"exec": [
									"tests[\"Status code is 200\"] = responseCode.code === 200;",
									"",
									"pm.test(\"Returns Valid Data Type\", function () {",
									"    if(responseCode.code == 200){",
									"        response = pm.response.json();",
									"        pm.expect(bytesVerify(response[\"universalProxy\"], 20)).to.eql(true);",
									"    }else{",
									"        pm.response.to.have.body(\"Invalid Input\")",
									"    }",
									"});",
									"",
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": ""
						},
						"url": "localhost:3000/proxy/getUniversalProxy",
						"description": "Gets the address of the Universal Proxy contract."
					},
					"response": []
				},
				{
					"name": "Sets the address of Function",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "247f5950-d61c-44be-b996-738fe4922cd2",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"function authVerify(authArray, res){",
									"  if((authArray.length != 4) ||",
									"      (!bytesVerify(authArray[0], 32)) ||",
									"      (!bytesVerify(authArray[1], 1)) ||",
									"      (!bytesVerify(authArray[2], 32)) ||",
									"      (!bytesVerify(authArray[3], 32)) )",
									"    {",
									"      return false;",
									"    }",
									"    else{return true}",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if (!bytesVerify(pm.iterationData.get(\"id\"), 4) ||",
									"        !bytesVerify(pm.iterationData.get(\"target\"), 20)) {",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425])  ",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/proxy/setTarget/?id={{id}}&target={{target}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["proxy", "setTarget", ""],
							"query": [
								{
									"key": "id",
									"value": "{{id}}"
								},
								{
									"key": "target",
									"value": "{{target}}"
								}
							]
						},
						"description": "Sets address that is delegate called to run a function's logic. This function must be called with an signed nonce from the Freight Trust Corp. account in the https body."
					},
					"response": []
				},
				{
					"name": "Sets the new Master Address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "a4f4acfe-ff97-418a-80b0-6383017296c3",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(!bytesVerify(pm.iterationData.get(\"newMaster\"), 20)){",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);    ",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/proxy/changeMaster/?newMaster={{newMaster}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["proxy", "changeMaster", ""],
							"query": [
								{
									"key": "newMaster",
									"value": "{{newMaster}}"
								}
							]
						},
						"description": "Sets address that is delegate called to run a function's logic. This function must be called with an signed nonce from the Freight Trust Corp. account in the https body."
					},
					"response": []
				},
				{
					"name": "Sets the the new controller address",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "7a7ddd7a-503c-4c0a-9517-5cca11d301f4",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if(!bytesVerify(pm.iterationData.get(\"newController\"), 20)){",
									"        pm.expect(pm.response.code).to.be.oneOf([400, 425]);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": {
							"raw": "localhost:3000/proxy/changeController/?newController={{newController}}",
							"host": ["localhost"],
							"port": "3000",
							"path": ["proxy", "changeController", ""],
							"query": [
								{
									"key": "newController",
									"value": "{{newController}}"
								}
							]
						},
						"description": "Sets the new controller address."
					},
					"response": []
				},
				{
					"name": "Pauses the execution",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "5ff0103c-d6c8-4def-a754-918b2e0fb4dd",
								"exec": [
									"function bytesVerify(proposed, bytes){ //proposed is the string to be checked, bytes is the byte size of the encoded data",
									"  return ((typeof proposed == \"string\") && (proposed.length == 2*bytes+2) && isHexStrict(proposed))",
									"}",
									"",
									"function isHexStrict(proposed){//I wrote a clone of web3.isHexStrict, so we don't have to run a node to test code",
									"  proposed = proposed.toLowerCase()",
									"  flag = (proposed.slice(0,2) == \"0x\")",
									"  for(i = 2;  i < proposed.length; i ++){",
									"    test = proposed.charAt(i)",
									"    flag = flag && (test <= '9' || ((test>='a')&&(test<='f')))",
									"  }",
									"  return flag",
									"}",
									"",
									"pm.test(\"Rejects Invalid Data Types\", function () {",
									"    if (!bytesVerify(pm.variables.get('sig'), 65)) {",
									"        pm.response.to.have.status(400);",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "678129f7-e23a-4cac-bdc9-d1d4b4828ef7",
								"exec": [""],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Accept",
								"value": "application/xml, application/json",
								"disabled": true
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"auth\" : { \n  \t\"sig\": \"{{sig}}\"\n  }\n}"
						},
						"url": "localhost:3000/proxy/pause",
						"description": "Calls the pause method in the universal proxy, blocking any state changes while Freight Trust updates."
					},
					"response": []
				}
			],
			"description": "Folder for proxy"
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "55da7c0a-0b77-4bb5-a9f8-6ef710ede7ba",
				"type": "text/javascript",
				"exec": [""]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "b4630f28-e7f7-44fb-bdc5-5ed4e244eb9e",
				"type": "text/javascript",
				"exec": [""]
			}
		}
	]
}
